<!-- MarkdownTOC -->

- [Unique global key](#unique-global-key)
	- [UUID](#uuid)
	- [Redis](#redis)
	- [Twitter Snowflake](#twitter-snowflake)
	- [MongoDB's Object Id](#mongodbs-object-id)
	- [Database ticket servers](#database-ticket-servers)
	- [Leaf](#leaf)
	- [Wechat seqsvr](#wechat-seqsvr)
	- [Design by yourself](#design-by-yourself)
	- [Industrial solution](#industrial-solution)

<!-- /MarkdownTOC -->


# Unique global key
## UUID
- UUID is the most simple way to generate a global unique ID - 32 bit HEX number. 
- UUID takes 128 bit. 

## Redis
* using Redis' incr instruction.
* Redis' incr / DB's auto increment need to happen on the master node, leading to low performance. 

## Twitter Snowflake 
* https://github.com/twitter-archive/snowflake/tree/snowflake-2010
* Snowflake algorithm is based on time granularity. 
* Upside: 
	1. 64-bit unique IDs
* Downside:
	1. Introduce another component in our infrastructure that needs to be maintained. 
	2. Limitation: when time is reset/rolled back, duplicated id will be generated.

## MongoDB's Object Id

## Database ticket servers
* DB's auto increment id

## Leaf

## Wechat seqsvr
* https://www.infoq.cn/article/wechat-serial-number-generator-architecture/

## Design by yourself
* The IDs generated by this sequence generator are composed of -
	- Epoch timestamp in milliseconds precision - 42 bits. The maximum timestamp that can be represented using 42 bits is 242 - 1, or 4398046511103, which comes out to be Wednesday, May 15, 2109 7:35:11.103 AM. That gives us 139 years with respect to a custom epoch.
	- Node ID - 10 bits. This gives us 1024 nodes/machines.
	- Local counter per machine - 12 bits. The counter’s max value would be 4095.

* References: https://www.callicoder.com/distributed-unique-id-sequence-number-generator/

## Industrial solution
* Use a composite key
	- The first part is the shard identifier (see “Mapping the Sharding Key” on page 206)
	- The second part is a locally generated identifier (which can be generated using AUTO_INCREMENT). 
	- Note that the shard identifier is used when generating the key, so if a row with this identifier is moved, the original shard identifier has to move with it. You can solve this by maintaining, in addition to the column with the AUTO_INCREMENT, an extra column containing the shard identifier for the shard where the row was created.
